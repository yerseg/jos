h1. Лабораторная работа №6

Помимо процессора, важным ресурсом компьютера является оперативная память. Часть операционной системы, которая ей управляет, называется диспетчером памяти. Простейший диспетчер памяти уже реализован в JOS и позволяет процессам и ядру выделять и освобождать память. Однако, как было сказано выше, на данном этапе развития JOS все процессы работают в едином адресном пространстве, то есть могут иметь прямой доступ к памяти друг друга и к памяти ядра ОС, что может привести к фатальным последствиям. Для решения этой проблемы используется модель виртуальной памяти.

В основе виртуальной памяти лежит идея, что у каждого процесса имеется свое собственное адресное пространство, разделенное на участки, называемые страницами. Каждая страница может быть отображена на участок физической памяти того же размера, но отображение всех возможных страниц сразу необязательно. При доступе к памяти программа использует не физические адреса, а виртуальные, которые затем с учетом таблицы страниц процесса транслируются процессором в физические. Кроме того, процессор может, например, ограничивать доступ процесса на запись в определенные страницы памяти — т. е. процесс может получить доступ к некоторым страницам памяти ядра без опасений, что он испортит его.

О поддержке управления памятью в процессорах x86 можно более подробно прочитать в главах 3-5 части 3А Руководства для разработчиков приложений для 64- и 32-разрядных архитектур Intel. На концептуальном уровне управление памятью описано в главе 3 книги Э. Таненбаума "Современные операционные системы".

Для получения файлов и изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab6, после чего выполнить слияние с ней ветви lab6, которая появилась в репозитории. О работе с git можно прочитать на [[GitManual|соответствующей странице]].

В данной работе вам будет необходимо реализовать аллокатор памяти, который позволит ядру выделять и освобождать память. Ваш аллокатор будет оперировать страницами памяти размером 4096 байт. Для его реализации нужно вести учет выделенных и свободных физических страниц, а также количества процессов, использующих каждую страницу.

Рассмотрим файлы, важные для выполнения лабораторной работы. Файл *memlayout.h* описывает структуру виртуального адресного пространства, которую необходимо реализовать путем изменения файла *pmap.c*. В *memlayout.h* и *pmap.h* определена структура PageInfo, которую вы будете использовать, чтобы отслеживать, какие страницы физической памяти свободны. *uefi.h* обладает структурой *EFI_MEMORY_DESCRIPTOR*, которая  хранит информацию о всех регионах физической памяти. Указатель на таблицу регионов памяти передается в *uefi_lp* из UEFI, и для корректного определения объема доступной памяти требуется полный проход по данной таблице.

Обратите особое внимание на *memlayout.h* и *pmap.h*, так как эта лабораторная работа требует, чтобы вы использовали и понимали многие из определений, которые они содержат. Вы можете также ознакомиться с *inc/mmu.h*, так как он также содержит ряд полезных определений.

h2. Использование виртуальной памяти для обхода зависимости от местоположения

Ядро операционной системы часто имеет очень высокий виртуальный адрес связывания, например, 0x8041500000, чтобы оставить нижнюю часть виртуального адресного пространства для пользовательских программ. Причины этого станут яснее в последующих лабораторных работах.

При этом многие компьютеры не имеют физической памяти по адресу 0x8041500000, поэтому мы не можем рассчитывать на возможность хранить там ядро. Вместо этого мы будем использовать инструменты процессора для управления памятью, чтобы сопоставить виртуальный адрес 0x8041500000 (адрес связывания, по которому код ядра ожидает быть запущенным) физическому адресу 0x01500000 (по которому загрузчик UEFI загружает ядро в физическую память). Таким образом, хотя виртуальный адрес ядра достаточно высок, чтобы оставить достаточно адресного пространства для UEFI загрузчика, оно будет загружено в физическую память в точку 21 МБ. Этот подход требует, чтобы компьютер имел хотя бы несколько мегабайт физической памяти (чтобы физический адрес 0x01500000 был доступен), но это условие скорее всего выполняется любым современным компьютером.

В этой и следующих лабораторных работах мы будем сопоставлять все доступное физическое адресное пространство компьютера, от 0x00000000 вплоть до 0x7FC0000000, виртуальным адресам от 0x8040000000 до 0x10000000000 соответственно.

На данный момент сопоставлены только первые BOOT_MEM_SIZE (1024 МБ) физической памяти, которых будет достаточно, чтобы дать возможность ядру запуститься и работать. Это делается с помощью написанных вручную и статически инициализируемых двухмегабайтовых таблиц в kern/bootstrap.S. До установки таблицы pml4 в регистр cr3 в kern/bootstrap.S ссылки на память рассматриваются как физические адреса. После установки таблицы pml4 ссылки на память являются виртуальными адресами, которые транслируются процессором в физические адреса (строго говоря, загрузчик UEFI уже установил свою собственную таблицу pml4 на процессоре, где установлено тождественное отображение из линейных адресов в физические, но как правило операционные системы всегда создают свои собственные таблицы). pml4 в bootstrap.S транслирует виртуальные адреса в диапазоне от 0x8040000000 до 0x8080000000 в физические от 0x00000000 до 0x40000000, а также виртуальные адреса от 0x00000000 до 0x40000000 в физические от 0x00000000 до 0x40000000. Помимо этого, в init.c в функции early_boot_pml4_init дополнительно происходит отображение участков памяти, необходимых для раннего доступа к передаваемым параметрам uefi_lp, инициализации ASAN, а также для доступа к чтению EFI_MEMORY_DESCRIPTOR из UEFI. Обращение по любому виртуальному адресу, который не находится в одном из этих двух диапазонов, вызовет аппаратное исключение, которое, так как мы еще не создали обработку прерываний, заставит QEMU завершиться из-за тройного исключения.

!{width:25%}mapping.png!

_Используйте QEMU и GDB, чтобы проследить работу ядра JOS и остановиться на movq %rax, %cr3. Изучите память по адресам 0x01600000 и 0x8041600000. Теперь выполните одну инструкцию, используя команду GDB stepi. Еще раз изучите память по адресам 0x01600000 и 0x8041600000. Убедитесь, что вы понимаете, что произошло._

_Какая инструкция первой не сможет выполниться правильным образом, если отображение не будет установлено? Закомментируйте movq %rax, %cr3 в kern/bootstrap.S, проследите выполнение и проверьте, были ли вы правы._

h2. Управление страницами

Операционная система должна отслеживать, какие части физической памяти в настоящий момент свободны, а какие используются. Данную задачу выполняет модуль, который называется менеджером памяти. Для эффективного управления памятью используется
одно дерево, описывающее физическую память системы (узлы дерева имеют тип struct Page — в менеджере памяти используется обобщенное понятие страницы, под которым подразумевается регион памяти имеющий размер равный степени 2 и адрес, выровненный
на этот размер). А также набор связанных списков свободных страниц для каждого используемого размера памяти. Обратите внимание, что память может именть различные типы (Описываемые enum PageState) и в списках свободных страниц могут находится только страницы типа ALLOCATABLE_NODE со счетчиком ссылок refc == 0 и без дочерних узлов.

Узлы деревьев (метаданные аллокатора) выделяются из самой памяти аллокатора и адресуются с использованием отображения физической памяти один-к-одному на KERN_BASE_ADDR. Выделение узлов произсходит из пулов узлов, которых хранятся в страницах и выделяются alloc_page() в флагом ALLOC_POOL при исчерпании свободных узлов из списка free_descriptors.

Для более удобной работы со списками используются функции работы со списками (list_). Допишите иx. Списки имеют пустой заголовочный узел и закольцованны т.е. пустой список состоит из одной структуры struct List list у которой &list == list.prev и &list = list->next. Функция освобождения узла делает из удаленного узла пустой список. 

_В файле kern/pmap.c необходимо исправить или написать функции, список которых приведен ниже._



!{width:25%}extfreemem.png!

* _detect_memory()_

_Инициализирует дерево физической памяти, используя карту памяти UEFI или данные из CMOS если первая не доступна.
В данной функции используется функция attach_region, которую необходимо дописать далее_

* _attach_region()_

_Присоединяет произольный регион памяти к физическому дереву, рабивая этот регион на страницы, выровненные на
степени 2 и имеющие размер кратный степени 2. Данная функция использует page_lookup для аллокации новой страницы
с параметром alloc равным 1_

* _alloc_child()_

_Вспомогательная функция, которая выделяет и инициализирует дочерний узел в дереве, описывающем физическую память.
Посмотрите на поля структуры Page и комментарии к функции, и подумайте, как инициализировать поля нового узла._


_Кроме того, необходимо добавить в монитор команду, выводящую список всех свободных страниц по классам вызывающую функцию dump_memory_lists() и саму эту функцию._

Функция check_physical_tree() и различные вызовы assert() в коде проверяют корректность аллокатора. Запустите JOS и убедитесь в том, что эти функции выполняются и код выводит необходимые сообщения на экран. При необходимости исправьте код так, чтобы эта функция срабатывала. Для отладки может быть полезным использование GDB и добавление различных вызовов assert(). При запуске JOS вы должны увидеть следующий вывод:

<pre>
Memory allocator is initiallized
Physical memory: 512M available, base = 640K, extended = 523648K
Physical memory tree is correct
enabled interrupts: 2
Initialized timer rtc
Initialized timer pm
Initialized timer hpet0
Initialized timer hpet1
Framebuffer initialised
enabled interrupts: 0 2
</pre>

При запуске make grade система должна проходить тесты.

_Примечание: поддержка ACPI (используется для таймеров HPET и PM) была отключена в данной лабораторной работе, убедитесь, что вы понимаете, почему это произошло и что необходимо сделать, чтобы её реализовать в дальнейшем._ 

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._