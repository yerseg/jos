h1. Лабораторная работа №10

Для получения файлов и изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab10, после чего выполнить слияние с ней ветви lab10, которая появилась в репозитории.

Файлы, которые появились в этой работе, в основном связаны с поддержкой файловой системы и расположены в новой директории fs. Просмотрите все файлы в этой директории. Кроме того, некоторые файлы, связанные с поддержкой файловой системы, появились в директориях user и lib.

После слияния кода данной работы запустите программы pingpong, primes и forktree из предыдущей работы. Для начала нужно закомментировать строку ENV_CREATE(fs_fs) в kern/init.c, потому что fs/fs.c пытается совершить некоторые еще не реализованные операции ввода/вывода. Кроме того, временно закомментируйте вызов close_all() в lib/exit.c; эта функция также использует еще не реализованные функции. Если ваши предыдущие работы выполнены верно, тесты должны работать правильно; не продолжайте, пока не убедитесь в этом. После выполнения первого упражнения раскомментируйте эти строки.

Поддержка файловой системы, которая поддерживает все базовые возможности (создание, чтение, запись, удаление файлов), в целом уже реализована. Вам нужно будет лишь изменить существующий код таким образом, чтобы файловая система заработала в JOS. Для этого необязательно знать все детали реализации файловой системы или ее структуру на диске, но важно ознакомиться с принципами ее работы и программным интерфейсом.

Файловая система реализована в микроядерном стиле, вне ядра, в пределах своего собственного пользовательского процесса (т. н. сервера файловой системы). Другие процессы получают доступ к файловой системе с помощью IPC-запросов.

h2. sys_region_refs()

Для реализации получения количества ссылок использующийся для pipe и в других функциях, необходимо реализовать вспомогательный системный вызов sys_region_refs() в ядре, который используется для реализации двух библиотечных вызовов -- sys_region_refs() и sys_region_refs2(). Первый из них возвращает максимальное количество ссылок на регион памяти. А второй -- разницу между количеством ссылок на два региона и в результате практически эквивалентен sys_region_refs(addr, size) - sys_region_refs(addr2, size2), за исключением того, что он выполняется атомарно, что помогает предотващать гонки в реализации pipe. 

h2. Доступ к диску

Сервер файловой системы в JOS должен получать доступ к диску, но эта возможность еще не реализована. Вместо того, чтобы использовать обычную стратегию монолитного ядра, — добавление IDE-драйвера в ядро вместе с необходимыми системными вызовами для доступа к файловой системе — IDE-драйвер будет реализован как часть сервера файловой системы. Однако для того, чтобы дать серверу файловой системы возможность непосредственно обращаться к диску, все же придется модифицировать ядро.

Реализовать доступ к диску в пользовательском пространстве несложно, если использовать PMIO или MMIO и не использовать дисковые прерывания. Можно реализовать дисковый драйвер, основанный на прерываниях, в пользовательском режиме (например, таким образом он реализован в ядрах L3 и L4), но это труднее, так как ядро должно отправлять дисковые прерывания нужному пользовательскому процессу.

x86-процессор использует биты IOPL в регистре EFLAGS, чтобы определить, разрешается ли коду защищенного режима выполнять специальные инструкции ввода-вывода, такие как IN и OUT. Так как все регистры IDE-дисков, к которым необходимо получить доступ, расположены в пространстве ввода/вывода x86, не отображаясь в память, единственное, что нужно сделать для доступа к ним — дать процессу привилегию I/O. В сущности, биты IOPL регистра EFLAGS обеспечивают простой метод контроля доступа к пространству ввода-вывода для кода пользовательского режима — «все или ничего». Для разграничения доступа нужно, чтобы сервер файловой системы имел возможность доступа к пространству ввода-вывода, а другие процессы не имели.

_Функция i386_init идентифицирует сервер файловой системы, передавая тип ENV_TYPE_FS в функцию создания процесса (env_create). Измените функцию env_create в env.c, чтобы она давала такому процессу привилегию ввода/вывода, но не давала ее никакому другому процессу._

_Убедитесь, что вы можете запустить сервер файловой системы без ошибки. При запуске make grade ваш код должен пройти тест «fs i/o»._

_Ответьте на следующий вопрос:_

* _Нужно ли сделать что-нибудь еще, чтобы убедиться, что привилегия ввода/вывода будет сохранена и восстановлена должным образом при переключении между процессами? Почему?_

В предыдущих лабораторных работах образ ядра вместе с пользовательскими программами после сборки находился в файле obj/kernel/kernel.img, который при запуске использовался QEMU как образ для диска 0 («Диск C:» в DOS/Windows). В данной работе происходит то же самое, но, помимо этого, в качестве образа для диска 1 («Диск D:») используется новый файл obj/fs/fs.img, в котором находятся в т.ч. новые пользовательские программы. Файловая система должна использовать только диск 1; диск 0 используется только для загрузки ядра.

h2. Кэш блоков

Кроме того, для файловой системы будет реализован простой кэш блоков с помощью системы виртуальной памяти процессора. Его код находится в fs/bc.c.

Файловая система будет иметь ограничение на размер диска — не более 3 ГБ. Для отображения в память диска резервируется фиксированная область адресного пространства сервера файловой системы размером 3 ГБ, от 0x10000000 (DISKMAP) до 0xD0000000 (DISKMAP + DISKMAX). Например, блок 0 отображается по виртуальному адресу 0x10000000, блок 1 отображается по виртуальному адресу 0x10001000 и т.д. Функция diskaddr в fs/bc.c реализует эту трансляцию из номеров блоков в виртуальные адреса (вместе с некоторыми проверками).

Так как сервер файловой системы имеет собственное виртуальное адресное пространство, независимое от адресных пространств других процессов, и единственное, что он должен делать — реализовать доступ к файлам, такое резервирование большей части адресного пространства допустимо. Для реальной реализации файловой системы на 32-битном процессоре это было бы странно, так как современные диски обычно больше 3ГБ. Однако для 64-битного процессора такой подход также может быть допустим.

Конечно, было бы неразумно читать в память сразу все содержимое диска. Вместо этого выделение страницы памяти и чтение необходимого блока с диска будет происходить при возникновении ошибки страницы. Таким образом создается иллюзия, что весь диск находится в памяти.

_Реализуйте функции bc_pgfault() и flush_block() в fs/bc.c. Функция bc_pgfault() используется в качестве обработчика ошибки страницы, при ее возникновении загружая страницу с диска. При ее написании имейте в виду, что (1) addr может не быть выровнен по границе блока и (2) ide_read оперирует секторами, а не блоками. Функция flush_block() записывает блок на диск, если необходимо, но ничего не делает в случаях, когда блок не находится в кэше или не помечен как dirty. Блок помечается как dirty (т.е. как измененный с тех пор, как было произведено чтение или запись) процессором при обращении к странице на запись (см. "4.8 ACCESSED AND DIRTY FLAGS" в Intel Software Developer Manual), то есть для проверки необходимости записи блока на диск достаточно проверить бит PTE_D в uvpt. После записи блока на диск функция flush_block() должна очищать флаг PTE_D с помощью sys_page_map._

_Используйте make grade для тестирования кода. Код должен проходить проверки «check_bc», «check_super», «check_bitmap»._

Функция fs_init() в fs/fs.c является ярким примером использования кэша. После инициализации кэша она записывает указатели (номера блоков) на область отображения диска в глобальной переменной super. С этого момента можно просто читать данные из структуры super, как если бы она находилась в памяти, а обработчик ошибок страницы будет читать их с диска по мере необходимости.

После установки в fs_init() указателя bitmap этот указатель можно рассматривать как битовый массив, в котором каждый бит соответствует блоку на диске; см., например, функцию block_is_free(), которая проверяет, помечен ли данный блок как свободный. 

_Реализуйте alloc_block() по аналогии с free_block(). Эта функция должна находить свободный блок в bitmap, помечать его как используемый и возвращать его номер. Сразу после выделения блока необходимо записать изменившийся блок на диск с помощью flush_block(), чтобы сохранить целостность файловой системы. После выполнения этого упражнения ваш код должен проходить проверку «alloc_block»._

h2. Операции с файлами

Основные функции для операций с файлами представлены в файле fs/fs.c. Просмотрите их и убедитесь, что вы понимаете, что делает каждая из функций.

_Реализуйте функции file_block_walk() и file_get_block(). После выполнения этого упражнения ваш код должен проходить проверки «file_open», «file_get_block», «file_flush/file_truncated/file_rewrite», «testfile»._

h2. Интерфейс файловой системы

Теперь, когда сервер файловой системы может получать доступ к диску, нужно сделать его доступным для других процессов, которые хотят использовать файловую систему. Так как другие процессы не могут напрямую вызывать функции в сервере файловой системы, доступ будет осуществляться с помощью удаленного вызова процедур, или RPC — абстракции, построенной на базе механизма IPC. Графически вызов сервера файловой системы (например, read()) изображен на рисунке:

!{width:33%}fsrpc.png!

Все, что ниже пунктирной линии, — просто механика передачи запроса на чтение от обычного процесса к серверу файловой системы. Функция read() работает на любых файловых дескрипторах и просто вызывает соответствующую функцию чтения для устройства, в данном случае devfile_read() (теоретически могут существовать различные типы устройств, такие как каналы). Функция devfile_read() реализует read() для файлов на диске. Эта и другие функции devfile_ * в lib/file.c реализуют клиентскую сторону операций с ФС и работают приблизительно одинаковым образом, собирая аргументы в структуру запроса, вызывая fsipc для отправки IPC-запроса, а затем распаковывая и возвращая результат. Функция fsipc обрабатывает отправку запроса к серверу и получение ответа.

Код сервера файловой системы можно найти в fs/serv.c. Он реализован как бесконечный цикл с функцией serve(), получающей запрос от IPC, диспетчеризующей запрос в соответствующую функцию-обработчик и отправляющей результат обратно через IPC. При выполнении операции чтения, например, serve() направит запрос в serve_read(), которая позаботится об особенностях IPC, соответствующих запросу на чтение, таких как распаковка структуры запроса и, наконец, вызов file_read(), фактически выполняющий чтение файла.

Напомним, что механизм межпроцессного взаимодействия JOS позволяет процессу отправить одно 32-битное число и, возможно, открыть страницу для совместного доступа. Для отправки запроса от клиента к серверу используется 32-битное число, обозначающее тип запроса (функции RPC сервера файловой системы пронумерованы, как и системные вызовы), а аргументы запроса хранятся в union Fsipc на странице, к которой открыт доступ с помощью IPC. На стороне клиента страница отображается с разделяемым доступом как fsipcbuf; на стороне сервера она отображается из входящего запроса в fsreq (0x0FFFF000).

Кроме того, сервер отправляет ответ обратно через IPC. 32-битное число здесь используется для кода возврата функции, и это единственное, что возвращает большая часть функций RPC. Однако FSREQ_READ и FSREQ_STAT также возвращают данные, просто записывая их на страницу, на которой клиент отправил запрос. Нет необходимости отправлять эту страницу в ответе IPC, так как изначально именно клиент отправил ее серверу файловой системы. Кроме того, в своем ответе FSREQ_OPEN открывает клиенту доступ к новой FD-странице (странице файлового дескриптора).

_Реализуйте функции serve_read(), serve_write() в fs/serv.c и devfile_write() в lib/file.c. Функция serve_read() должна, по сути, просто предоставлять интерфейс к функции file_read(). Просмотрите комментарии и код в функции serve_set_size(), чтобы понять, как должны быть устроены функции сервера файловой системы._

_После этого код должен проходить проверки «serve_open/file_stat/file_close», «file_read», «file_write», «file_read after file_write», «open» и «large file»._

_После выполнения этого задания рекомендуется проверить разработанный код с помощью make grade. Скрипт должен выводить OK для всех тестов._

_В заключение работы ответьте на следующий вопрос:_

* _Что плохого может произойти с файловой системой при неожиданном отключении питания? Как этого можно избежать?_

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._