h1. Лабораторная работа №9

h2. Введение

Для получения файлов и изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab9, после чего выполнить слияние с ней ветви lab9, которая появилась в репозитории. О работе с git можно прочитать на [[GitManual|соответствующей странице]].

В этой лабораторной работе вы реализуете некоторые базовые системные вызовы для управления процессами (вызовы, которые создают и уничтожают процессы, выделяют память), системный вызов fork(), позволяющий процессам создавать копии себя, а также механизм межпроцессного взаимодействия (IPC, inter-process communication), позволяющий различным пользовательским процессам явным образом передавать друг другу сообщения.

h2. Системные вызовы для создания процессов

В настоящий момент ядро уже может запускать процессы и переключаться между ними, но по-прежнему ограничивается процессами, которые само запустило. Далее будут реализованы системные вызовы, необходимые для создания и запуска новых пользовательских процессов уже запущенными.

В Unix для создания процессов используется системный вызов fork(). Вызов fork() копирует все адресное пространство вызывающего (родительского) процесса, создавая новый (дочерний) процесс. Единственное различие между двумя процессами, наблюдаемое из пользовательского пространства — идентификаторы самих процессов и родительских процессов (getpid() и getppid()). В родительском процессе fork() возвращает идентификатор созданного дочернего процесса, а в дочернем — 0. Обычно каждый процесс получает свое собственное адресное пространство, и модификации памяти, выполняемые другими процессами, ему не видны.

Далее нужно разработать набор более примитивных, чем fork(), системных вызовов для создания новых пользовательских процессов в JOS. С помощью этих системных вызовов можно будет затем реализовать Unix-подобный fork() и другие способы создания процессов полностью в пользовательском пространстве. Вы должны написать следующие системные вызовы для JOS:

* _envid_t sys_exofork(void):_
Создает новый почти чистый процесс: ничего не отображено в пользовательской части его адресного пространства, и он не является runnable. Новый процесс должен иметь то же состояние регистров, что и родительский в момент вызова sys_exofork. В родительском процессе sys_exofork должен возвращать envid_t вновь созданного процесса (или отрицательный код ошибки, если создать процесс не удалось). В дочернем процессе он должен вернуть 0. (Поскольку дочерний процесс изначально не-runnable, он не выйдет из sys_exofork, пока родитель не сделает его runnable с помощью следующего вызова).

* _int sys_env_set_status(envid_t envid, int status):_
Устанавливает состояние указанного процесса в ENV_RUNNABLE или ENV_NOT_RUNNABLE. Этот системный вызов, как правило, используется для обозначения того, что новый процесс готов к запуску, когда его адресное пространство и регистры полностью инициализированы.

* _int sys_alloc_region(envid_t envid, void *va, size_t size, int perm):_
Лениво выделяет регион страничной памяти по данному виртуальному адресу в адресном пространстве данного процесса. Память заполнена нулями (ALLOC_ZERO) или 0xFF (ALLOC_ONE).

* _int sys_map_region(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, size_t size, int perm):_
Отображает регион папяти одного процесса на некоторый адрес другого (или того же самого) процесса.

* _int sys_unmap_region(envid_t envid, void *va):_
Удаляет отображенный регион памяти из данного процесса заданного размера.

Для всех системных вызовов, которые принимают идентификаторы процессов, ядро поддерживает соглашение о том, что значение 0 (константа CURENVID) означает «текущий процесс». Это соглашение осуществляется с помощью envid2env() в kern/env.c.

В тестовой программе user/dumbfork.c написана примитивная реализация Unix-подобного fork(). Эта программа использует системные вызовы, указанные выше, для создания и запуска дочернего процесса с копией своего собственного адресного пространства. Затем два процесса переключаются между собой, используя sys_yield. Родительский процесс завершает работу после 10 итераций, а дочерний — после 20.

_Реализуйте системные вызовы, описанные выше, в kern/syscall.c. Для этого нужно будет использовать различные функции из kern/pmap.c и kern/env.c, в том числе envid2env(). При вызове envid2env() передавайте 1 в качестве параметра checkperm. Убедитесь, что вы проверяете аргументы системных вызовов на правильность, при необходимости возвращая -E_INVAL. Кроме того, необходимо будет исправить функцию env_destroy, чтобы она поддерживала работу нескольких пользовательских процессов одновременно. Проверьте ядро с помощью user/dumbfork и убедитесь, что оно работает, прежде чем продолжать._

h2. Fork() с копированием при записи

Как было сказано ранее, в Unix системный вызов fork() используется в качестве основного способа создания процессов. Вызов fork() копирует адресное пространство вызывающего процесса (родительского), создавая новый процесс (дочерний).

Тем не менее, очень часто после вызова fork() почти сразу происходит вызов exec() в дочернем процессе, который заменяет его память новой программой. В этом случае время, потраченное на копирование адресного пространства родительского процесса, будет потрачено почти впустую, потому что дочерний процесс использует лишь незначительную часть своей памяти до вызова exec().

Поэтому в современных версиях Unix используется аппаратная поддержка виртуальной памяти, чтобы родительский и дочерний процессы делили между собой память, отображаемую в их адресные пространства, до момента, когда один из процессов ее изменит. Этот метод известен как копирование при записи (copy-on-write). Для этого при вызове fork() ядро будет копировать от родительского процесса к дочернему только отображение адресного пространства, но не содержимое отображенных страниц, и одновременно отмечать эти общие страницы как «только для чтения». Когда один из двух процессов попытается записать что-либо в одну из общих страниц, произойдет ошибка страницы. При возникновении этой ошибки ядро создаст новую, доступную для записи копию страницы для процесса, вызвавшего ошибку. Таким образом, содержимое отдельных страниц не будет фактически скопировано, пока в них не будет произведена запись. Эта оптимизация делает вызов fork(), а затем exec() дочерним процессом гораздо быстрее: ему, вероятно, нужно будет скопировать только одну страницу (текущую страницу своего стека) до вызова exec().

В следующей части этой лабораторной работы вы реализуете «правильный» Unix-подобный fork() с копированием при записи в качестве библиотечной функции с использованием sys_exofork() и sys_map_region() (последний может предоставлять небохдимый интерфейс, при вызове с нужными аргуметами и копировать все адресное пространство лениво за один системный вызов).

h2. Реализация fork() c копированием при записи 

Поток управления fork() заключается в следующем:

1. Родитель вызывает sys_exofork(), чтобы создать дочерний процесс.

2. Родитель отображает свое адресное пространство на пространство дочернего процесса с использованием флагов PROT_ALL, PROT_LAZY и PROT_COMBINE (Подумайте, почему используется именно такая комбинация флагов?)

3. Родительский процесс устанавливает такую же, как у себя, точку входа в обработчик ошибки страницы в дочернем процессе.

4. Дочерний процесс в настоящее время готов работать, так что родитель помечает его runnable.

_Реализуйте fork, duppage и pgfault в lib/fork.c._

_Проверьте свой код программой forktree. Она должна выдавать следующие сообщения, с вкраплениями сообщений “new env”, "free env" и “exiting gracefully”. Сообщения необязательно появляются в таком порядке, и идентификаторы процессов могут отличаться._

<pre>	1000: I am ''
	1001: I am '0'
	2000: I am '00'
	2001: I am '000'
	1002: I am '1'
	3000: I am '11'
	3001: I am '10'
	4000: I am '100'
	1003: I am '01'
	5000: I am '010'
	4001: I am '011'
	2002: I am '110'
	1004: I am '001'
	1005: I am '111'
	1006: I am '101'
</pre>

h2. Обработка ошибок страниц в пользовательском режиме

Для более гибкой реализации выделения shadow памяти для UASAN, необходимо реализовать возможность обрабатывать в пользовательском режиме ошибки при доступе к страницам, защищенным от записи.
Это только одно из многих возможных применений для такой возможности. Необходимость выполнять некоторое действие при возникновении ошибки страницы возникает во множестве различных случаев. Например, большинство ядер Unix-подобных операционных систем изначально отображает только одну страницу в области стека нового процесса; дополнительные страницы выделяются и отображаются по мере увеличения размера стека процесса, при возникновении ошибок страниц при доступе по адресам в стеке, которые еще не отображены (это реализовано в JOS на уровне ядра благодаря поддержке ленивой аллокации/копирования). Обычно ядро должно предпринимать разные действия при возникновении ошибки страницы в разных областях адресного пространства процесса. Например, ошибка в области стека, как правило, требует выделения и отображения новой страницы физической памяти. При ошибке в области BSS, как правило, нужно также выделить и отобразить новую страницу, а также заполнить ее нулями. В некоторых системах исполняемые файлы выделяют память по необходимости: при ошибке в сегменте .text будут прочитаны с диска и отображены соответствующие страницы.

h2. Установка обработчика ошибки страницы

Для того, чтобы обрабатывать ошибки страниц, пользовательскому процессу нужно зарегистрировать точку входа обработчика ошибок страниц в ядре. Он делает это при помощи нового системного вызова sys_env_set_pgfault_upcall. Для хранения этой информации к структуре Env было добавлено поле env_pgfault_upcall.

_Реализуйте sys_env_set_pgfault_upcall. Не забудьте проверку разрешений при поиске идентификаторов процессов, так как это «опасный» системный вызов._

h2. Обычный стек и стек исключений в пользовательских процессах

Во время нормальной работы программы пользовательский процесс будет использовать обычный стек: его регистр rsp изначально указывает на USTACKTOP, а данные, добавляемые в стек, находятся между USTACKTOP-USTACKSIZE и USTACKTOP-1 включительно. Однако при возникновении ошибки страницы ядро запускает обработчик ошибок страниц с использованием стека пользовательского исключения. Таким образом, происходит автоматическое «переключение стека» аналогично тому, как процессор x86 переключает стек при переходе из пользовательского режима в режим ядра.

Cтек пользовательского исключения JOS имеет размер в одну страницу, а его вершина определяется виртуальным адресом UXSTACKTOP, то есть данные стека находятся от UXSTACKTOP-PGSIZE до UXSTACKTOP-1 включительно. Во время работы обработчик ошибок страниц пользовательского режима может использовать обычные системные вызовы JOS для добавления новых отображений страниц или настройки отображений таким образом, чтобы исправить проблему, изначально вызвавшую ошибку страницы. Затем обработчик через обертку, написанную на языке ассемблера, переходит к коду, вызвавшему ошибку, который будет использовать обычный стек.

Каждый пользовательский процесс, использующий обработку ошибок страниц в пользовательском режиме, должен выделить память для своего собственного стека исключений с помощью sys_page_alloc().

h2. Вызов пользовательского обработчика ошибок страниц

Теперь вам необходимо изменить код обработки ошибок страниц в kern/trap.c для обработки ошибок страниц из пользовательского режима, как описано ниже.

Если зарегистрированный обработчик ошибки страницы отсутствует, ядро ​​JOS уничтожает пользовательский процесс с соответствующим сообщением, как и ранее. В противном случае ядро добавляет кадр стека исключений, который выглядит как структура UTrapframe в inc/trap.h:

!{width:25%}utf.png!

Затем ядро организует для пользовательского процесса продолжение работы с обработчиком ошибки страницы, работающим на стеке исключений с этого кадра стека. Вы должны выяснить, как правильно реализовать такое поведение. Значение fault_va — это виртуальный адрес, который вызвал ошибку страницы.

Если пользовательский процесс уже запущен на стеке исключения при возникновении исключения, значит, обработчик ошибки страницы сам вызвал ошибку. В этом случае вы должны начать новый кадр стека сразу после текущего tf-> tf_rsp, а не с UXSTACKTOP. Вы должны сначала добавить в стек пустое 32-разрядное слово, а затем структуру UTrapframe.

Для проверки, находится ли tf_rsp в пользовательском стеке исключения, проверьте, находится ли его значение в диапазоне между UXSTACKTOP-PGSIZE и UXSTACKTOP-1 включительно.

_Реализуйте необходимый для отправки ошибок страниц обработчику пользовательского режима код в page_fault_handler в kern/trap.c. Примите соответствующие меры предосторожности при записи данных в стек исключений. (Что произойдет, если у пользовательского процесса закончится пространство в стеке исключений?)_

Для того чтобы предотвратить рекурсивную ошибку страничной адресации, необходимо выделить стек исключений явно (с помощью force_alloc_page которая также используется для ленивого выделения.)
Так как KASAN не должен проверять обращения к пользовательской памяти используйте nosan_memcpy для записи в пользовательский стек исколючений.

h2. Точка входа ошибки страницы пользовательского режима 

Далее вам нужно реализовать процедуру на языке ассемблера, которая будет вызывать обработчик ошибки страницы на С и возобновлять выполнение с инструкции, которая вызвала обработчик ошибки. Эта процедура — обработчик, который будет зарегистрирован ядром с помощью sys_env_set_pgfault_upcall().

_Реализуйте _pgfault_upcall в lib/pfentry.S. Важным моментом является возвращение в исходную точку пользовательского кода, вызвавшую ошибку страницы: оно происходит без перехода в ядро. Сложность заключается в одновременном переключении стеков и значения RIP._

_Наконец, дополните реализацию пользовательской части механизма обработки ошибок страниц — add_pgfault_handler() в lib/pgfault.c._

_Пользовательский интерфейс поддерживает установку цепочки обработчиков исключений для того чтобы упростить обработку различных областей памяти по разному. (Например, в следующей лабораторной файловая система будет использовать обработчик исключений для реализации дискового кеша одновременно с UASAN, использующим данный обработчик для выделения shadow памяти). Обработчики вызываются по очереди, до тех пор пока не встретится обработчик вернувший истину в качестве реазультата, что есть сигнал библиотеке о том что исключение обработано. Если не одини обработчик из загеристрированных не вернул истину, вызывается panic._

h2. Выделение Shadow памяти

Реализуйте выделение shadow памяти в качестве пользовательского обработчика исключений.
Обратите внимание, что он должен выделять память только для shadow памяти, не соответствующей части ей самой.
Дополните код выделения памяти в обработчике #PF в llvm/asan/asan_platform.ujos.c.

h2. Тестирование

Запустите user/faultread. Вы должны увидеть:
<pre>...
<0x80201070e8> Page fault ip=00800029 va=00000000 err=-U--- -> fault
[00001000] user_mem_check assertion failure for va=0000007ffffffec0 ip=0000000000800029
[00001000] free env 00001000
Halt
</pre>

Запустите user/faultdie. Вы должны увидеть:

<pre>...
<0x80201070e8> Page fault ip=0080008D va=DEADBEEF err=-UW-- -> redirected to user
i faulted at va deadbeef, err 6
[00001000] exiting gracefully
[00001000] free env 00001000
Halt
</pre>

Запустите user/faultalloc. Вы должны увидеть:

<pre>...
<0x80201070e8> Page fault ip=0080000F va=7FFFFF6FF8 err=PUW-- -> resolved by kernel
<0x80201070e8> Page fault ip=008006EF va=BEEFDEAD err=-U--- -> redirected to user
fault beefdead
<0x80201070e8> Page fault ip=0080045A va=BEEFDEAD err=PUW-- -> resolved by kernel
this string was faulted in at beefdead
<0x80201070e8> Page fault ip=008006EF va=CAFEBFFE err=-U--- -> redirected to user
fault cafebffe
<0x80201070e8> Page fault ip=0080045A va=CAFEBFFE err=PUW-- -> resolved by kernel
<0x80201070e8> Page fault ip=0080045A va=CAFEC000 err=-UW-- -> redirected to user
fault cafec000
<0x80201070e8> Page fault ip=0080045A va=CAFEC000 err=PUW-- -> resolved by kernel
this string was faulted in at cafebffe
[00001000] exiting gracefully
[00001000] free env 00001000
Halt
</pre>

Если вы видите только первую строку «this string...», это означает, что вы не обрабатываете рекурсивные ошибки страниц должным образом.

Запустите user/faultallocbad. Вы должны увидеть:
<pre>...
[00001000] user_mem_check assertion failure for va=00000000deadbeef ip=00000000008010bb
[00001000] free env 00001000
Halt
</pre>

Убедитесь, что вы понимаете, почему user/faultalloc и user/faultallocbad ведут себя по-разному.

h2. Межпроцессное взаимодействие (IPC)

Ранее мы сосредоточились на изоляции процессов и способах создания иллюзии, что для каждой программы компьютер находится в полном ее распоряжении. Другой важной функцией операционной системы является связь программ между собой. Возможность для программ взаимодействовать между собой достаточно важна. Канонический пример — модель pipe'ов в Unix.

Существуют различные модели межпроцессного взаимодействия, каждая из которых имеет свои достоинства и недостатки. Далее мы реализуем одну из таких моделей.

h2. IPC в JOS

С точки зрения процесса механизм межпроцессного взаимодействия будет реализован в виде двух новых системных вызовов, sys_ipc_recv() и sys_ipc_try_send(), и двух библиотечных оберток для них, ipc_recv() и ipc_send().

«Сообщения», которые пользовательские процессы могут отправить друг другу, используя механизм IPC JOS, состоят из двух компонентов: 32-битное значение и опциональный регион памяти. Разрешение для процессов передавать регионы памяти в сообщениях обеспечивает эффективный способ передать больше данных, чем может поместиться в одно 32-битное целое число, а также позволяет процессам использовать общую память.

h2. Отправка и прием сообщений

Для получения сообщения процесс вызывает sys_ipc_recv. Этот системный вызов усыпляет текущий процесс и не запускает его снова, пока сообщение не получено. Когда процесс ждет сообщения, любой другой процесс может послать ему сообщение — необязательно некий конкретный процесс, и необязательно процесс, имеющий с принимающим связи родительский/дочерний. Другими словами, при IPC не происходит никакой проверки прав доступа, так как его механизм разработан так, чтобы быть «безопасным»: один процесс не может испортить другой путем посылки IPC-сообщения.

Чтобы попытаться отправить сообщение, процесс вызывает sys_ipc_try_send с id целевого процесса и значением, которое будет отправлено. Если указанный процесс действительно в данный момент принимает сообщения (вызвал sys_ipc_recv и еще не получил значение), то функция доставляет сообщение и возвращает 0. В противном случае функция возвращает -E_IPC_NOT_RECV, чтобы указать, что целевой процесс в данный момент не ожидает сообщения.

Функция ipc_recv в пользовательском пространстве вызывает sys_ipc_recv и ищет информацию о полученных значениях в struct Env текущего процесса. Аналогично, функция ipc_send вызывает sys_ipc_try_send до тех пор, пока передача не удастся.

h2. Передача страниц

Когда процесс вызывает sys_ipc_recv с правильным параметром dstva (ниже UTOP), он таким образом заявляет, что готов получить страницу. Если отправитель посылает страницу, то эта страница будет отображена по адресу dstva в адресном пространстве получателя. Если получатель уже имеет страницу, отображенную по адресу dstva, то отображение этой страницы удаляется.

Когда процесс вызывает sys_ipc_try_send с правильным srcva (ниже UTOP), это означает, что отправитель хочет отправить регион, отображенную в данный момент по адресу srcva, с разрешениями perm. После успешного осуществления IPC отправитель сохраняет свое первоначальное отображение по адресу srcva в своем адресном пространстве, а получатель принимает отображение для этой же памяти по адресу dstva, первоначально указанному получателем, в адресном пространстве получателя. В результате эта страница становится общей для отправителя и получателя.

Если отправитель или получатель не заявляют, что должен быть передан регион, то он не передается. После любого IPC ядро устанавливает новое поле env_ipc_perm в структуре Env получателя на права доступа к полученной памяти, или 0, если она не была не была получена. При отображении используется минимальный размер памяти из указанных получателем и отправителем.

_Реализуйте sys_ipc_recv и sys_ipc_try_send в kern/syscall.c. Прочитайте комментарии к обеим функциям до их реализации, так как они должны работать вместе. При вызове envid2env в этих функциях вы должны установить флаг checkperm в 0, это означает, что любой процесс имеет право отправлять IPC-сообщения любому другому процессу, и ядро не делает никаких специальных проверок разрешений, кроме подтверждения того, что целевой envid является правильным._

_Затем реализуйте функции ipc_recv и ipc_send в lib/ipc.c._

_Используйте user/pingpong и user/primes для тестирования механизма IPC. Вам также может быть интересно прочитать user/primes.c, чтобы понять, что происходит._

_После выполнения этого задания рекомендуется проверить разработанный код с помощью make grade. Скрипт должен выводить OK для всех тестов._

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._
