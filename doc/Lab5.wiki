h1. Лабораторная работа №5

Для получения файлов, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab5, после чего выполнить слияние с ней ветви lab5, которая появилась в репозитории. О работе с git можно прочитать на [[GitManual|соответствующей странице]].

h2. Поддержка HPET

В предыдущей лабораторной работе мы реализовали поддержку вытесняющей многозадачности с помощью таймера RTC. Хотя для наших задач данный метод даёт приемлемую частоту переключения задач, в настоящее время RTC используется исключительно для получения календарного времени. Кроме RTC на x86-совместимых системах доступны и другие таймеры, в том числе HPET (High Precision Event Timer), который позволяет прозрачно заменить функционал таймера RTC. HPET имеет нескольких таймеров, доступных для конфигурирования. В репозиторий были добавлены файлы timer.c и timer.h. В данных файлах представлена простая абстракция для поддержки различных таймеров в JOS. Воспользуйтесь спецификацией HPET (доступна в файлах) и реализуйте поддержку для двух таймеров HPET (hpet0 и hpet1) с периодами генерации прерываний 0.5 и 1.5 секунд соответственно. Замените код обработки сигнала EOI в файле trap.c на использование функции handle_interrupts из структуры timer_for_schedule. Добавьте код обработки прерывания таймера в trap_init аналогично с прерыванием часов.

Для реализации поддержки HPET вам будет необходимо получить доступ к таблицам ACPI: RSDP (функция get_rsdp) и HPET (функция get_hpet). Алгоритмы получения доступа к таблицам ACPI на различных системах описаны в спецификации ACPI. Для упрощения доступа к ним используется функция find_acpi_table, которую также требуется реализовать.

Для настройки прерываний от таймеров HPET реализуйте функции hpet_enable_interrupts_timX и hpet_handle_interrupts_timX. Для простоты реализации поддержки HPET предлагается использовать режим LegacyReplacement, который задействует прерывания на линиях 0 и 8 для hpet0 и hpet1 соответственно.

Выбор таймера производится с помощью функции timers_init в init.c. После выполнения задания убедитесь, что операционная система корректно работает со всеми таймерами, поддерживающими планировщик задач: hpet0, hpet1, rtc.

h2. Синхронизация между процессами

При параллельной работе нескольких процессов с одной и той же областью памяти могут возникать состояния гонки. В случае с JOS, например, при выделении памяти процессы могут одновременно обращаться к списку свободных страниц, так как все процессы в настоящий момент работают в одном адресном пространстве и вышеупомянутый список является для них общим. Для предотвращения состояний гонки используется синхронизация между процессами, реализуемая с помощью примитивов синхронизации, таких как мьютексы, семафоры, блокировки с активным ожиданием (спинлоки) и т.д. В данном задании необходимо использовать реализованные в JOS спинлоки для синхронизации между процессами при выделении и освобождении памяти.

_В репозиторий были добавлены файлы alloc.c и spinlock.c. В первом находится исходный код аллокатора памяти, которым пользуются процессы для выделения и освобождения памяти. Во втором — механизм блокировок с активным ожиданием. Необходимо добавить в функции test_alloc и test_free (файл alloc.c) защиту блокировками (функции spin_lock, spin_unlock) таким образом, чтобы функции выделения и освобождения памяти не могли работать со списком страниц одновременно, чтобы процессы, которые одновременно их вызывают, не могли повредить список свободных страниц памяти._

_Ошибка повреждения списочной структуры хранения блоков свободной памяти проявляет себя нерегулярно. Уменьшив интервал срабатываний таймера, можно увеличить вероятность ее возникновения. При возникновении ошибки на экран выводится строка вида: kernel panic at kern/alloc.c:20: Corrupted list._

h2. Time Stamp Counter

Следующее упражнение заключается в реализации секундомера. В процессорах архитектуры x86 есть 64-битный регистр TSC (Time Stamp Counter), в котором находится число тактов процессора с его последнего сброса (reset). Инструкция rdtsc копирует значение TSC в регистры EDX:EAX (32 страрших бита в каждом из регистров RDX и RAX обнуляются). Зная частоту процессора (число тактов в секунду) и количество тактов между двумя моментами времени, можно вычислить прошедшее между ними время. В настоящий момент на процессорах Intel TSC используется как средство высокоточного замера прошедшего времени. На некоторых современных процессорах частоту можно извлечь с помощью инструкции CPUID из ветвей ART (см. "функцию InternalCalcluateARTFrequencyIntel":https://github.com/acidanthera/OpenCorePkg/blob/master/Library/OcCpuLib/FrequencyDetect.c), в нашем случае средством подсчёта частоты будет являться другой таймер.

_В репозиторий были добавлены файлы tsc.h и tsc.c. В них уже реализован подсчет частоты процессора с помощью PIT (Programmable Interval Timer) — рекомендуется ознакомиться с этим кодом. Ваша задача заключается в реализации функций timer_start, timer_stop и timer_cpu_frequency из tsc.c. Функции timer_start и timer_cpu_frequency принимают в качестве аргумента название таймера (hpet0, hpet1, pit, pm). Если функция timer_stop была вызвана после timer_start, она должна выводить на экран время в секундах между этими вызовами. В случае вызова timer_stop без предварительного вызова timer_start должна выводиться ошибка._

_Для поддержки остальных таймеров также реализуйте схожим образом функции hpet_cpu_frequency и pmtimer_cpu_frequency. Описание таймера ACPI PowerManagement можно найти в спецификации ACPI. Обратите внимание, что он может быть как 24-битным, так и 32-битным. Пример учёта данной особенности можно найти в "функции InternalCalculateTSCFromPMTimer":https://github.com/acidanthera/OpenCorePkg/blob/master/Library/OcCpuLib/FrequencyDetect.c ._

_Для проверки необходимо добавить команды монитора timer_start, timer_stop и timer_freq, которые будут вызывать функции timer_start, timer_stop и timer_cpu_frequency соответственно. Чтобы система переходила в монитор, нужно отключить старт бесконечно выполняющихся программ в kern/init.c._

_Внимание: код подсчёта частоты процессора с таймером pit может некорректно работать в VirtualBox — программа никогда не выходит из цикла в функции tsc_calibrate(). В таком случае можно использовать другие таймеры._

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._