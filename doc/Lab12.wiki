h1. Лабораторная работа №12

В данной работе будет реализовано окружение, необходимое для запуска простого варианта программы "date":http://www.gnu.org/software/coreutils/date - без поддержки часовых поясов, локализации, установки даты и т.д. Для этого требуется реализовать системный вызов, получающий из CMOS текущее время.

Кроме того, будет реализована поддержка системных вызовов в стиле vsyscall - без переключения контекста.

Для получения изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab12, после чего выполнить слияние с ней ветви lab12, которая появилась в репозитории.


h2. Получение текущего времени

Для получения текущего времени от часов RTC необходимо прочитать данные из памяти CMOS, аналогично [[Lab4|лабораторной работе №4]]. Данные расположены в указанных ниже регистрах CMOS, для которых также заданы соответствующие константы в kern/kclock.h:

|_.Регистр |_.Значение |
|  0x00    |  Секунды  |
|  0x02    |  Минуты   |
|  0x04    |  Часы     |
|  0x07    |  День     |
|  0x08    |  Месяц    |
|  0x09    |  Год      |

Данные хранятся в двоично-десятичном формате (BCD). Для конвертации их в двоичный формат можно использовать макрос BCD2BIN.

Микросхема часов RTC работает относительно медленно, поэтому раз в секунду, когда происходит обновление времени, RTC может выдавать неправильные значения. Например, в момент обновления с 8:59:59 до 9:00:00 из часов могут быть прочитаны не только эти два значения, но и 8:59:00 или 8:00:00. Для обработки такой ситуации существует бит Update in progress (бит 7 в регистре А - 0x0A), однако просто проверить этот бит на 0 недостаточно: обновление времени может начать происходить и после этого. Простой способ обработать такую ситуацию - дождаться, пока этот бит станет равным 0, после чего прочитать значения два раза и сравнить: если они изменились, значит, произошло обновление времени и полученные данные могут быть неверными; в таком случае необходимо прочитать их еще раз.

Часто используется представление времени в виде одного числа (UNIX time, POSIX time, timestamp): количества секунд с 00:00:00 1 января 1970 года. Этот формат удобен для передачи времени, в частности, между программой и ОС посредством системного вызова. Функции для конвертации времени в этот формат и из него присутствуют в inc/time.h.

_Получите текущее время из CMOS в формате UNIX time в функции gettime в kern/kclock.c._

_Реализуйте системный вызов sys_gettime._

_Теперь программа date должна выдавать текущее время (в часовом поясе UTC)._

h2. Системные вызовы без переключения контекста

В связи с необходимостью переключения контекста, обычные системные вызовы являются относительно медленными. Системные вызовы, которые только получают данные от ядра, но не отправляют, в Linux реализуются без переключения контекста путем простого чтения разделяемой между ядром и процессами памяти; при этом задача ядра - держать получаемые данные в актуальном состоянии.

Программа vdate использует такой псевдо-системный вызов vsys_getdate, однако для его работы необходимо реализовать описанный выше механизм, а также записать по известному процессам адресу текущее время.

_В inc/memlayout.h задана константа UVSYS, равная 0. Измените ее и другие значения таким образом, чтобы она соответствовала некому выделенному пространству для разделяемых данных._

_В kern/pmap.c выделите массив для разделяемых данных (длина массива определяется в inc/vsyscall.h) и отобразите его только для чтения для пользовательских процессов по адресу UVSYS._

_В lib/entry.S добавьте переменную, соответствующую этой области памяти, для пользовательских программ._

_В lib/vsyscall.c реализуйте чтение ячейки памяти с номером, соответствующим системному вызову (номера заданы в inc/vsyscall.h)._

_Кроме того, добавьте обновление нужной ячейки памяти при срабатывании прерывания от часов._

_Теперь программа vdate также должна выдавать текущее время (в часовом поясе UTC)._

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._