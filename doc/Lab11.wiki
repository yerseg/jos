h1. Лабораторная работа №11

h2. Введение

В результате выполнения предыдущих работ было реализовано управление памятью, процессами, исключениями и прерываниями, системные вызовы, работа с внешними накопителями. Однако почти отсутствуют средства взаимодействия с пользователем: такое взаимодействие производится с помощью нескольких наперед заданных команд монитора, не позволяющих даже запускать произвольные программы, либо путем автоматического внесения изменений в код при запуске ОС (команды для запуска программ make run-X).

Простым и универсальным способом взаимодействия с операционной системой является текстовый интерфейс, реализацией которого является командная оболочка. Она присутствует в различном виде почти во всех операционных системах. В JOS командная оболочка в основном уже реализована, далее будут добавлены возможности операционной системы, необходимые ей для работы, и некоторые возможности самой оболочки. Помимо последовательного выполнения команд (REPL — Read-Eval-Print Loop) оболочка также поддерживает их пакетное выполнение из файлов на внешнем накопителе.

Для получения изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab11, после чего выполнить слияние с ней ветви lab11, которая появилась в репозитории.

h2. Запуск процессов

В репозиторий был добавлен код функции spawn(), которая создает новый процесс, загружает в него образ программы из файловой системы, а затем запускает. Родительский процесс затем продолжает выполнение независимо от дочернего. Функция spawn(), по сути, соответствует выполнению fork() с последующим выполнением в дочернем процессе exec().

Мы реализовали spawn() вместо exec(), потому что spawn() легче реализовать в пространстве пользователя в стиле экзоядра, без использования средств ядра. Подумайте, что необходимо для реализации exec() в пространстве пользователя, и убедитесь, что вы понимаете, почему такой вариант труднее.

Допишите функцию отображения сегмента в дочернем процессе -- map_segment() в spawn.c. Она использует файловые API и системные вызовы для работы с памятью.

_Функция spawn() использует новый системный вызов sys_env_set_trapframe() для инициализации состояния вновь созданного процесса. Реализуйте sys_env_set_trapframe(). Проверьте свой код, запустив user/spawnhello в kern/init.c. Эта программа будет пытаться выполнить spawn() для программы /hello в файловой системе._

_Используйте make grade для тестирования написанного кода. Если при выполнении user/spawnhello возникает ошибка страницы (сообщение «page fault in FS»), проследите, как работает сервер файловой системы, и подумайте, что произойдет, если в системе не останется ни одного процесса кроме него._

h3. Разделение файловых дескрипторов между родительским процессом и процессами, порожденными fork и spawn

Файловые дескрипторы UNIX являются общим понятием, включающим в себя также каналы, консольный ввод-вывод и т.д. В JOS каждый из этих типов устройств имеет соответствующую структуру struct Dev с указателями на функции, реализующими чтение, запись и т. д. для данного типа устройств. В файле lib/fd.c находится реализация интерфейса UNIX-подобных файловых дескрипторов на ее основе. Каждая структура struct Fd соответствует своему типу устройства; большинство функций в lib/fd.c просто вызывает функции в соответствующих структурах Dev.

В lib/fd.c также находится управление начинающимися с FSTABLE таблицами дескрипторов в адресном пространстве каждого процесса. Эта область памяти резервирует страницу (4 КБ) памяти для каждого из файловых дескрипторов, которые программа может открыть одновременно (до MAXFD — в настоящее время 32). В любой момент времени каждая страница таблицы дескрипторов отображена только в том случае, если используется соответствующий дескриптор. Каждый дескриптор также имеет дополнительную «страницу данных» в области памяти, начинающейся с FILEDATA, которую устройства могут использовать, если им это необходимо.

Сейчас при вызове fork() эта память будет отмечена скопирована правильно, так как она отображается с флагом PROT_SHARE. (Посмторите на реализацию map_region() в ядре и выясните почему это работает правильно) Однако после вызова spawn() память вообще не будет скопирована, то есть запущенные процессы начинают работать без открытых файловых дескрипторов. Необходимо, чтобы память родительского процесса, относящаяся к файловым дескрипторам, была доступна из дочерних процессов. Для этого нужно реализовать foreach_shared_region(), которая на данный момент является no-op, а должна вызывать переданную функцию для каждой страницы с флагом PTE_SHARE.

PTE_SHARE соответствует одному из трех бит записи таблицы страниц, которые описаны как «доступные для использования программами» в руководствах Intel и AMD. Мы установим соглашение, что, если у записи в таблице страниц установлен этот бит, данная запись должна быть скопирована непосредственно от родительского процесса к дочернему, даже если map_region вызван с флагом PROT_LAZY. О

_Используйте make run-testpteshare, чтобы проверить, что ваш код работает правильно. Вы должны увидеть строки «fork handles PTE_SHARE right» и «spawn handles PTE_SHARE right»._

_Используйте make run-testfdsharing, чтобы проверить, что файловые дескрипторы правильно разделяются. Вы должны увидеть строки «read in child succeeded» and «read in parent succeeded»._

h2. Клавиатура

Чтобы командная оболочка могла работать, нужно обрабатывать вводимые с клавиатуры данные. Ранее QEMU отображал вводимые с клавиатуры данные на дисплей и в последовательный порт, но ввод до сих пор использовался только при работе с монитором. В QEMU данные, вводимые в графическом окне, передаются в JOS в качестве входных данных с клавиатуры, в то время как данные, вводимые в консоли, передаются через последовательный порт. Файл kern/console.c уже содержит драйвера клавиатуры и последовательного порта, которые монитор ядра использовал начиная с работы №1, но теперь вам нужно объединить их с остальной частью системы.

_В файле kern/trap.c вызовите kbd_intr() для обработки IRQ_OFFSET+IRQ_KBD и serial_intr() для обработки IRQ_OFFSET+IRQ_SERIAL._

_Проверьте свой код, вызвав make run-testkbd и введя что-либо с клавиатуры. Система должна показать введенные символы. Попробуйте вводить текст как в консоли, так и в графическом окне._

h2. Командная оболочка

Выполните make run-icode или make run-icode-nox. Запустится JOS, а в ней user/icode, который, в свою очередь, запускает user/init. Init устанавливает консольный ввод-вывод как файлы с дескрипторами 0 (ввод) и 1 (вывод). Затем init запускает sh — командную оболочку. В оболочке попробуйте выполнить следующие команды:

<pre>
echo hello world | cat
cat lorem |cat
cat lorem |num
cat lorem |num |num |num |num |num
</pre>

Обратите внимание, что пользовательская библиотечная функция cprintf выводит данные напрямую в консоль, не используя файловый дескриптор. Это удобно для отладки, но не дает возможности передать выводимые данные в другие программы. Чтобы вывести данные в конкретный файловый дескриптор, используйте fprintf(1, "...", ...). Функция printf выводит данные в дескриптор 1. В файле user/lsfd.c можно увидеть примеры использования этих функций.

_Командная оболочка не поддерживает перенаправление ввода-вывода. Реализуйте его в файле user/sh.c. После этого вы должны иметь возможность выполнить команды:_

<pre>
cat script
sh <script
</pre>

_Выполните make run-testshell, чтобы проверить командную оболочку. Программа testshell просто выполняет команды, указанные выше, и сравнивает вывод с файлом fs/testshell.key. На данный момент ваш код должен проходить все тесты, запускаемые make grade._

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._