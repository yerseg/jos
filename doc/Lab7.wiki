h1. Лабораторная работа №7

Для получения файлов и изменений, необходимых для выполнения работы, следует обновить удаленный репозиторий, создать новую ветвь под названием working-lab7, после чего выполнить слияние с ней ветви lab7, которая появилась в репозитории. О работе с git можно прочитать на [[GitManual|соответствующей странице]]. Начиная с данной лабораторной работы для облегчения отладки написанного кода имеется доступ к ядерному AddressSanitizer, с инструкцией по использованию которых можно ознакомиться [[LLVM Sanitizers|по ссылке]]. Все решения лабораторных работ должны быть проверены с помощью AddressSanitizer (и UndefinedBehaviorSanitizer, который был доступен ранее). В случае несовместимости инструмента с лабораторной работой должно быть приведено соответствующее обоснование с описанием причин (например, ограничения по памяти).

h2. Виртуальная память

Перед продолжением ознакомьтесь с архитектурой управления памятью x86, а именно с сегментацией и со страничной трансляцией. Изучите Intel Software Developer Manual (во вложении). Разделы, касающиеся сегментации, не следует пропускать: JOS использует страничную организацию памяти, но сегментная трансляция и сегментная защита памяти не могут быть отключены на процессорах x86 в режиме IA-32, а режим x64, хотя и не использует сегментацию памяти, все еще требует использование глобальной таблицы дескрипторов (GDT), так что вам потребуются базовые знания о них.

В терминологии x86 виртуальный адрес состоит из селектора сегмента и смещения внутри сегмента. Линейный адрес получается после сегментной трансляции, но до страничной трансляции. Физический адрес является результатом сегментной и страничной трансляции; в конечном итоге, на аппаратном уровне используется именно он.

!{width:50%}translation.png!

Указатель в языке С содержит компонент «смещение» виртуального адреса. В LoaderPkg/.../Transition.nasm мы установили глобальную таблицу дескрипторов (GDT), которая отключила сегментную трансляцию путем установки всех базовых адресов сегментов в 0 и размеров в 0xFFFFFFFF. Таким образом, «селектор» не имеет никакого эффекта и линейный адрес всегда равен смещению виртуального адреса. Стоит отметить, что в режиме x64 в таблице дескрипторов разрешены только "линейные" сегменты, и фактически сегментация памяти не используется.

При страничной трансляции информация об отображении физических страниц на виртуальные хранится в многоуровневом каталоге страниц. Адрес текущего каталога страниц наивысшего уровня должен находиться в контрольном регистре CR3; таким образом, процессор может переключаться между несколькими каталогами страниц для разных процессов и ядра.

!{width:75%}pml4.png!

При использовании страниц, отображающих четыре килобайта памяти, наивысшим уровнем таблицы страниц является четвертый. В таблице страниц четвертого уровня (PML4) хранятся структуры PML4E (Page Map Level 4 Entry — запись карты страниц четвертого уровня), в которых содержится адрес физической страницы для таблицы указателей на каталог страниц (PDP - Page Directory Pointer) и флаги для нее. В свою очередь, таблицы указателей на каталог страниц содержит структуры PDPE (Page Directory Pointer Entry — запись указателя на каталог страниц), в которых содержится адрес для каталога страниц и флаги для нее. Далее, в каталоге страниц хранятся структуры PDE (Page Directory Entry — запись каталога страниц), в которых содержится адрес физической страницы для таблицы страниц и флаги для нее. Наконец, в таблице страниц содержатся структуры PTE (Page Table Entry — запись таблицы страниц), в которых содержится адрес конкретной физической страницы и флаги для нее.  Таким образом, каталог страниц для таблиц размером 4 килобайта является четырехуровневым, а виртуальный адрес состоит из пяти компонент: номера PML4E, номера PDPE, номера PDE, номера PTE и смещения на конкретной странице.

В PML4E, PDPE, PDE заданы следующие флаги:

* S — Size, размер страницы: может быть выставлен только в PDE и PDPE; если бит выставлен, то размер страницы 2МБ и 1ГБ соответственно.
* A — Accessed, обращение. Процессор устанавливает этот флаг каждый раз, когда обращается к таблице для чтения или записи.
* D — Cache Disabled, запрещение кэша. Запрещает кэширование таблицы страниц.
* W — Write Through, сквозная запись. Управляет кэшированием страниц.
* U — User, пользовательская таблица. Если установлен — таблица доступна из пользовательского режима, если нет — только из режима ядра.
* R — Read/Write, чтение/запись. Определяет тип доступа к таблице: если установлен — таблица доступна на запись, если нет — только на чтение.
* P — Present, присутствие. Означает, что страница отображена и может использоваться при трансляции адреса.

В PTE заданы несколько другие флаги:

* G — Global. Влияет на процесс кэширования страниц (в JOS не используется).
* D — Dirty, изменение. Процессор устанавливает этот флаг каждый раз, когда обращается к странице для записи.
* A — Accessed, обращение. Процессор устанавливает этот флаг каждый раз, когда обращается к странице для чтения или записи.
* C — Cache Disabled, запрещение кэша. Запрещает кэширование страницы.
* W — Write Through, сквозная запись. Управляет кэшированием страниц (в JOS не используется).
* U — User, пользовательская страница. Если установлен — страница доступна из пользовательского режима, если нет — только из режима ядра.
* R — Read/Write, чтение/запись. Определяет тип доступа к странице: если установлен — страница доступна на запись, если нет — только на чтение.
* P — Present, присутствие. Означает, что страница отображена и может использоваться при трансляции.
* NX -  No execute, без выполнения. Если данный бит выставлен, то исполнение кода в данной странице запрещено (в JOS не используется).

В inc/mmu.h содержатся макросы для работы с таблицами страниц.

В kern/bootstrap.S задан простой каталог страниц, позволяющий ядру работать по своему адресу связывания 0x8041600000, хотя на самом деле оно загружается в физическую память сразу после ROM BIOS по адресу 0x1600000. Этот каталог отображает первые 1024МБ памяти. В данной работе это пространство будет расширено до всей доступной памяти (вплоть до ~500ГБ), начиная с виртуального адреса 0x8040000000.

_В то время как GDB может обращаться к памяти QEMU только по виртуальным адресам, часто бывает полезно иметь возможность контролировать физическую память при настройке виртуальной памяти. Изучите команды монитора QEMU в [[QEMU|соответствующем разделе]], особенно команду xp, которая позволяет просматривать физическую память._

_Используйте команду xp монитора QEMU и команду х GDB для проверки памяти по соответствующим физическим и виртуальным адресам и убедитесь, что вы видите одни и те же данные._

Для дальнейшей работы также могут быть полезны команды info mem (показывает обзор отображенных областей виртуальной памяти и их разрешения) и info pg (показывает компактное, но детальное представление текущих таблиц страниц, включая все отображенные диапазоны памяти, разрешения и флаги).

При нахождении в защищенном (32-битном) и "длинном" (64-битном) режиме нет никакого способа непосредственно использовать линейный или физический адрес. Все ссылки на память интерпретируются как виртуальные адреса и транслируются MMU (Memory Management Unit — блок управления памятью процессоров x86). Это означает, что все указатели в C содержат виртуальные адреса.

Периодически возникает необходимость манипулировать физическими и виртуальными адресами как значениями или как целыми числами, без разыменования, например, в аллокаторе физической памяти. Для этого в JOS используется два типа: uintptr_t представляет собой виртуальный адрес, а physaddr_t — физический. Оба типа являются синонимами для 64-разрядных целых чисел (uint64_t), поэтому компилятор не запретит присвоение значения одного типа переменной другого. Так как эти типы не являются указателями, их невозможно напрямую разыменовать. Для разыменования uintptr_t можно привести его к указателю, однако разыменовать физический адрес разумным образом нельзя, так как MMU преобразовывает все обращения к памяти. Если привести physaddr_t к указателю, можно обращаться по этому виртуальному адресу, но он, скорее всего, не будет соответствовать необходимому физическому. 

Иногда необходимо обращаться к памяти, для которой известен только физический адрес. Например, добавление отображения в таблицу страниц может потребовать выделения физической памяти для хранения каталога страниц, а затем инициализации этой памяти. Тем не менее, ядро, как и любое другое программное обеспечение, не может обойти трансляцию адресов и, следовательно, не может напрямую использовать физические адреса. Одна из причин, по которым JOS распределяет всю физическую память, начиная с физического адреса 0, по виртуальному адресу 0x8040000000 — необходимость помочь ядру использовать память, для которой оно знает только физический адрес. Для того, чтобы перевести физический адреса в виртуальный, которые ядро может использовать, нужно добавить к физическому адресу 0x8040000000. Для этого следует использовать макрос KADDR(pa).

Иногда нужно, наоборот, найти физический адрес по виртуальному адресу, где хранятся данные ядра. Глобальные переменные ядра и память, выделенная для метаданных, находятся в области, где ядро было загружено, начиная с 0x8040000000 (KERN_BASE_ADDR) — в той самой области, куда мы отобразили всю физическую память. Таким образом, чтобы превратить виртуальный адрес в этой области в физический, нужно просто вычесть 0x8040000000. Для этого следует использовать макрос PADDR(va).

h2. Управление таблицами страниц

В JOS используются адресные пространства (struct address_space) в качестве абстракции над таблицами страниц процессора. Они содержат в себе сами таблицы страниц, а также дерево, описывающее отображение виртуальных страниц на адреса. Именно это дерево используется ядром для работы с адересным пространством. Листовые узлы этого дерева содержат сслыки на виртуальные страницы физической памяти, отображенные на соответствующий виртуальный адрес. Эти узлы имеют тип MAPPING_NODE, тогда как промежуточные имеют тип INTERMEDIATE_NODE.

В качестве функции доступных в качестве интерфейса, используются map_region()/unmap_region()/map_physical_region()/mmio_map_region()/mmio_remap_last_region()/region_maxref(), которые могут обрабатываать произвольные регионы памяти.

Внутри себя они вызывают низкоуровневые функции, оперирующие виртуальными страницами, описывающие выравненные на свой размер регионы размера, являющегося степенью 2. Среди них 

* page_lookup_vitual()/page_lookup() -- функция поиска страницы в виртуальном/физическом дереве. В них обрабатываются все нихкоуровневые детали ленивого выделения частей дерева.

* page_map()/page_unmap() -- функции для отображения виртуальных страниц на адресные пространства

* page_ref()/page_unref() -- функции для управления ссылками на страницы физического дерева, использующиеся для управления выделением физической памятью.

* alloc_page() -- функция выделения физических страниц.

_В файле kern/pmap.c необходимо реализовать чаасть кода следующих функций:_

* _page_unmap_
Убирает отображение (из дерева страниц ядра и аппаратных таблиц страниц) виртуальной страницы в адресном пространстве, переданном в качестве аргумента.

* _page_map_
Убирает отображение (в дерево страниц ядра и на аппаратную таблицу страниц) виртуальнуой страницы в адресном пространстве, переданном в качестве аргумента. 

* _switch_address_space_
Выполняет переключение между адресными пространствами.

* _memcpy_page_
Копирует виртуальную страницу по заданнуму виртальному адресу в некотором адресном пространстве. 

h2. Адресное пространство ядра

JOS делит 64-битное линейное адресное пространство процессора на три части. Пользовательские процессы будут контролировать схему и содержимое нижней части, а ядро всегда сохраняет полный контроль над двумя верхними частями. Разделительная линия определяется условно символом ULIM в файле inc/memlayout.h, резервируя пространство для ядра с 0x803fc00000 до 0x10000000000. Именно для этого нужен такой высокий адрес связывания ядра: в противном случае было бы недостаточно места в виртуальном адресном пространстве для отображения пользовательских процессов ниже ядра. Третьим регионом является полная иерархия таблицы PM4, хранимой по адресу 0x10000000000 (что соответствует вхождению pml4 по индексу 2). 

Поскольку и память ядра, и память пользователя присутствуют в адресном пространстве каждого процесса, нужно использовать биты разрешений в таблицах страниц, чтобы разрешить пользователю доступ только к пользовательской части адресного пространства. В противном случае ошибки в пользовательском коде могут изменить данные ядра, что может привести к сбоям или ошибкам; пользовательский код может также получить доступ к данным других процессов.

Пользовательские процессы не будут иметь разрешений для любой памяти выше ULIM, в то время как ядро сможет читать и писать в эту память. Данный адрес соответствует границе вхождения pml4 по индексу 0, то есть адресу 0x8000000000. Для диапазона адресов [UTOP, ULIM) и ядро, и пользовательские процессы имеют одинаковые разрешения: они могут читать, но не писать в этот диапазон адресов. Этот диапазон адресов используется для предоставления определенных структур данных ядра пользовательским процессам только для чтения. Наконец, адресное пространство ниже UTOP доступно для использования пользовательским процессам: процесс может сам задавать разрешения для доступа к этой памяти.

Теперь следует правильным образом отобразить адресное пространство выше UTOP — часть адресного пространства, принадлежащую ядру. В файле inc/memlayout.h показана схема, которую следует использовать. Для создания соответствующих отображений нужно использовать map_physical_region, использующий функции, дописанные в предыдущем задании.

_Допишите недостающий код в init_memory()._

Теперь код должен проходить проверки check_virtual_tree() и check_physical_tree(). После выполнения этого задания рекомендуется проверить разработанный код с помощью make grade. Скрипт должен выводить OK для всех тестов.

Дополнительно, реализуйте функции dump_virtual_tree() и dump_page_table() из pmap.c, a также команды монитора mon_virt() и mon_pagetable(), их использующие.

_Мы поместили пользовательские процессы и ядро в одном адресном пространстве. Почему пользовательские программы не смогут читать или писать в память ядра? Какие конкретные механизмы защищают память ядра?_

_Каков максимальный объем физической памяти, который данная операционная система может поддерживать? Почему?_

_Сколько дополнительных затрат памяти потребовалось бы для управления памятью, если мы на самом деле имели максимальный объем физической памяти? На какие части эти накладные расходы разбиты?_

_Изучите еще раз механизм настройки таблицы страниц в kern/bootstrap.S. Сразу после включения страничной организации памяти RIP по-прежнему имеет низкое значение (чуть более 21 МБ). В какой точке мы переходим к использованию RIP выше KERNBASE? Что делает возможным продолжение выполнения с низким RIP между моментом, когда мы включаем страничную организацию, и моментом, когда мы начинаем использовать RIP выше KERNBASE? Почему этот переход необходим?_

_По окончании выполнения работы следует сохранить внесенные изменения и отправить их в удаленный репозиторий._
